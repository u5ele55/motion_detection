# motion_detection
## Тестовое задание по разделу «Видеоаналитика»

### Технологии и ограничения:
-	Языки программирования: Java, Python, C++;
-	Дополнительные библиотеки: OpenCV;

### Постановка задачи:

1.	Реализовать программный модуль опроса видеокамеры.  Для теста можно использовать видеокамеру Axis 214  192.168.217.103.
При этом допускается использование библиотеки Opencv.

2.	Разработать два варианта детектора движения для выделения объектов переднего плана:
   - детектор движения с использование функционала библиотеки opencv;
   -  детектор движения без использования сторонних библиотек;

3.	С помощью оптического потока разработать модуль сопровождения (трекинга) объекта, выделенного при реализации п.2. При этом отобразить сглаженную траекторию движения объекта.

### Промежуточные результаты
#### OpenCV
![изображение](https://github.com/u5ele55/motion_detection/assets/99137907/585c4152-1e67-466f-9a68-af9e90c63988)

#### Без OpenCV
![изображение](https://github.com/u5ele55/motion_detection/assets/99137907/06b87502-d577-4ff8-911f-b4683771e9ef)


### Основные идеи
- Усреднение последних N кадров и вычитание из результата текущего кадра - так получается получить изменение на текущем кадре по сравнению с предудыщими.
- Найденные отличаюбщиеся регионы обводим в прямоугольники. Если получается так, что внутри какого-то прямоугольника оказывается другой прямоугольник - удаляем его.
- Для избежания фиксирования шума следим за центрами движущихся объектов. Если обнаруженное движение не может иметь ни один из центров с прошлого кадра - скорее всего, это шум.
- Чтобы не терять объект "из виду", вводим параметр ожидания - максимальное количество кадров, которое объекту разрешается оставаться неподвижным перед тем, как признать его недвигающимся.
- Аналогично, чтобы не фиксировать излишние мелкие движения, требуем от объекта движения на протяжении некоторого количества кадров для того, чтобы признать его движущимся.
#### Для собственной реализации
- Python слишком медленный, рассматривать каждый пиксель картинки - затратно. Будем смотреть изменения на пикселях в заданной сетке (рассматривать каждые Ny, Nx пикселей по вертикали и горизонтали).
- В разности кадра и среднего за последние N кадров находим элемент, больший заданного порога, и далее от него запускаем поиск в ширину (тоже с некоторым шагом My, Mx), чем выделяем фигуру, после чего описываем вокруг неё прямоугольник.
